{
  parserClass="com.alekseyzhelo.evilislands.mobplugin.script.EIScriptParser"

  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptPsiElement"
  extends="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptPsiElementImpl"

  psiClassPrefix="EI"
  psiImplClassSuffix="Impl"
  psiPackage="com.alekseyzhelo.evilislands.mobplugin.script.psi"
  psiImplPackage="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl"

  elementTypeHolderClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptTypes"
  elementTypeClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptElementType"
  tokenTypeClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptTokenType"

  psiImplUtilClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptPsiImplUtil"
  generateTokenAccessors=false
}

//utility---------------
//                     |
//                    \|/
scriptFile ::= functionDeclaration+ | globalVars? declarations? scripts? worldScript?
// apparently this structure is not enforced by game.exe,
// declarations and implementations can be interspersed through the script text
// such disorder will not stand, of course

// utility
private meta comma_separated_list ::= <<param>> ( &RPAREN | (( COMMA <<param>> )*))
{
  pin(".*")=1
}

private meta comma_separated_list_rec ::= <<comma_separated_list <<param>>>>
{
  recoverWhile='<<recover>>'
}

//noinspection BnfUnusedRule
private ignored ::= (WHOLE_LINE_COMMENT COMMENT) // just to generate the ScriptToken

functionDeclaration ::= IDENTIFIER formalParams (COLON type)?
{
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EICallableDeclaration"
  methods=[getActualType getCallableParams getCallableType]
}
// utility end

private formalParams ::= LPAREN <<comma_separated_list (formalParameter)>>? RPAREN {pin=1}

formalParameter ::= IDENTIFIER COLON type
{
  pin=1
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
}

globalVars ::= GLOBALVARS LPAREN globalVarsDefs? RPAREN  {pin=1 methods=[toString]}

declarations ::= scriptDeclaration+  {methods=[toString]}

scripts ::= scriptImplementation+  {methods=[toString]}

worldScript ::= WORLDSCRIPT LPAREN scriptThenBody RPAREN {pin=1 recoverWhile=worldScriptRecover methods=[toString]}

private globalVarsDefs ::= <<comma_separated_list (globalVar)>>
// TODO: custom lists for global vars, params, formal params?
//  (external rule like com.intellij.lang.java.parser.ExpressionParser.parseArgumentList)?
//private globalVarList ::= globalVar ( &RPAREN | (( COMMA globalVar )*))
//{
//  pin(".*")=1
//  recoverWhile=comma_separated_list_recover
//}

globalVar ::= IDENTIFIER COLON type
{
  pin=1
  recoverWhile=globalVarRecover
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
  methods=[toString]
}

// TODO: do script params shadow global vars?
scriptDeclaration ::= DECLARESCRIPT IDENTIFIER formalParams
{
  pin=1
  recoverWhile=scriptDeclarationRecover
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EICallableDeclaration"
  methods=[getCallableParams getCallableType toString]
}

scriptImplementation ::= SCRIPT IDENTIFIER LPAREN scriptBlock+ RPAREN  // or *?
{
  pin=1
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptImplementationMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
  methods=[getReference toString]
} // TODO implements own interface?

// TODO: flatten this out as well?
scriptBlock ::= scriptIfBlock scriptThenBlock {pin=1 recoverWhile=scriptBlockRecover methods=[toString]}

scriptIfBlock ::= IF LPAREN functionCall* RPAREN {pin=1 recoverWhile=scriptIfBlockRecover methods=[toString]}

//  recoverWhile=scriptThenBlockRecover
scriptThenBlock ::= THEN LPAREN scriptThenBody RPAREN  {pin=1 recoverWhile=scriptThenBlockRecover methods=[toString]}

private scriptThenBody ::= scriptStatement*

// TODO: how to do references here?
scriptStatement ::= forBlock
                  | expressionStatement
{
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIStatementBase"
}

expressionStatement ::= functionCall | assignment {extends=scriptStatement methods=[getType toString]}
// TODO: Sum and ForIf?
// TODO: pin=2?
// TODO: annotation for For arguments!  | more or less done
forBlock ::= FOR LPAREN variableAccess COMMA reference_expression RPAREN LPAREN expressionStatement* RPAREN
{
  pin=1
  extends=scriptStatement
  methods=[getType toString]
}

expression ::= reference_expression
             | literal
{
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIExpressionBase"
  consumeTokenMethod="consumeTokenFast"
}

literal ::= FLOATNUMBER | CHARACTER_STRING
{
  extends=expression
  methods=[getType getReference toString]
  consumeTokenMethod="consumeTokenFast"
}

private reference_expression ::= functionCall | variableAccess

// TODO: append !LPAREN ?
variableAccess ::= IDENTIFIER
{
  extends=expression
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
  methods=[getReference getType toString]
  consumeTokenMethod="consumeTokenFast"
}

// TODO: incomplete call (no LPAREN) breaks following calls in ifBlock - is that a problem?
functionCall ::= IDENTIFIER params
{
  extends=expression
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
  methods=[getReference getType getNthArgument toString]
  consumeTokenMethod="consumeTokenFast"
}

// TODO: type checking!
//params ::=  LPAREN <<comma_separated_list (expression)>>? RPAREN {pin=1}
params ::=  non_empty_params | empty_params  // EI script has very few empty params in general
private empty_params ::= LPAREN RPAREN { consumeTokenMethod = 'consumeTokenFast' }
private non_empty_params::= LPAREN <<comma_separated_list_rec expression comma_separated_list_recover>> RPAREN
{
  pin = 1
  consumeTokenMethod = 'consumeTokenFast'
}

// TODO: handle no error on right part missing
assignment ::= variableAccess EQUALS expression
{
  extends=expression
  pin=1
  recoverWhile=scriptAssignmentRecover
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIAssignmentMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIAssignmentMixin"
  methods=[getType toString]
}

type ::= FLOAT | STRING | OBJECT | GROUP
{
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EITypeMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EITypeMixin"
}

private globalVarRecover ::= !(IDENTIFIER | COMMA | RPAREN)
private scriptDeclarationRecover ::= !(DECLARESCRIPT | SCRIPT)
private scriptIfBlockRecover ::= !(THEN)
private scriptThenBlockRecover ::= !(IF | RPAREN !RPAREN)
private scriptAssignmentRecover ::= !(RPAREN | IDENTIFIER)
private scriptBlockRecover ::= !(IF | RPAREN)
private worldScriptRecover ::= !(RPAREN)
private comma_separated_list_recover ::= !(RPAREN)  // wrong, interferes with other recovers! // TODO: still relevant?
