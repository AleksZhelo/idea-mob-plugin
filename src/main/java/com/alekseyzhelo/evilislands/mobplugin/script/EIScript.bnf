{
  parserClass="com.alekseyzhelo.evilislands.mobplugin.script.EIScriptParser"

  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptPsiElement"
  extends="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptPsiElementImpl"

  psiClassPrefix="EI"
  psiImplClassSuffix="Impl"
  psiPackage="com.alekseyzhelo.evilislands.mobplugin.script.psi"
  psiImplPackage="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl"

  elementTypeHolderClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptTypes"
  elementTypeClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptElementType"
  tokenTypeClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptTokenType"

  psiImplUtilClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptPsiImplUtil"
}

//utility---------------
//                     |
//                    \|/
scriptFile ::= functionDeclaration+ | globalVars? declarations? scripts? worldScript?

// utility
private meta comma_separated_list ::= <<param>> ( &RPAREN | (( COMMA <<param>> )*)) {pin(".*")=1 recoverWhile=comma_separated_list_recover}

//noinspection BnfUnusedRule
private ignored ::= (WHOLE_LINE_COMMENT COMMENT) // just to generate the ScriptToken

functionDeclaration ::= IDENTIFIER formalParams (COLON type)? {mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EICallableDeclaration" methods=[getActualType getCallableParams getCallableType]}
// utility end

globalVars ::= GLOBALVARS LPAREN globalVarsDefs? RPAREN  {methods=[toString]}

// apparently this structure is not enforced by game.exe, declarations and implementations can be interspersed through the script text
// such disorder will not stand, of course
declarations ::= scriptDeclaration+  {methods=[toString]}

scripts ::= scriptImplementation+  {methods=[toString]}

worldScript ::= WORLDSCRIPT LPAREN scriptThenBody RPAREN {pin=2 recoverWhile=worldScriptRecover methods=[toString]}

private globalVarsDefs ::= <<comma_separated_list (globalVar)>>

globalVar ::= IDENTIFIER COLON type {pin=1 recoverWhile=globalVarRecover mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin" methods=[toString]}

// TODO: do script params shadow global vars?
scriptDeclaration ::= DECLARESCRIPT IDENTIFIER formalParams {pin=1 recoverWhile=scriptDeclarationRecover mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EICallableDeclaration" methods=[toString getCallableParams getCallableType]}

scriptImplementation ::= SCRIPT IDENTIFIER LPAREN scriptBody RPAREN {pin=1 mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptImplementationMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin" methods=[getReference]} // TODO implements own interface?

private scriptBody ::= scriptBlock+  // or *?

// TODO: flatten this out as well?
scriptBlock ::= scriptIfBlock scriptThenBlock {pin=1 recoverWhile=scriptBlockRecover methods=[toString]}

scriptIfBlock ::= IF LPAREN ifConjunction RPAREN {pin=1 recoverWhile=scriptIfBlockRecover methods=[toString]}

private ifConjunction ::= functionCall*

//  recoverWhile=scriptThenBlockRecover
scriptThenBlock ::= THEN LPAREN scriptThenBody RPAREN  {pin=2 recoverWhile=scriptThenBlockRecover methods=[toString]}

private scriptThenBody ::= scriptExpression*

// TODO: how to do references here?
scriptExpression ::=  functionCall | forBlock | assignment {methods=[getType toString]}

// TODO: Sum and ForIf?
forBlock ::= FOR LPAREN variableAccess COMMA variableAccess RPAREN LPAREN scriptThenBody RPAREN

private formalParams ::= LPAREN <<comma_separated_list (formalParameter)>>? RPAREN

formalParameter ::= IDENTIFIER COLON type  {pin=1 mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"}

// TODO: how to do references here?
expression ::= FLOATNUMBER | CHARACTER_STRING | functionCall | variableAccess {methods=[getReference getType toString]}

// TODO: append !LPAREN ?
variableAccess ::= IDENTIFIER {mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin" methods=[getReference getType toString]}

functionCall ::= IDENTIFIER params {mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin" methods=[getReference getType getNthArgument toString]}

// TODO: type checking!
params ::=  LPAREN <<comma_separated_list (expression)>>? RPAREN {pin=1}

// TODO: handle no error on right part missing
assignment ::= variableAccess EQUALS expression {pin=1 recoverWhile=scriptAssignmentRecover methods=[toString]} // TODO: this pin and error recovery stuff

type ::= FLOAT | STRING | OBJECT | GROUP {mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EITypeMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EITypeMixin"}

private globalVarRecover ::= !(IDENTIFIER | COMMA | RPAREN)
private scriptDeclarationRecover ::= !(DECLARESCRIPT | SCRIPT)
private scriptIfBlockRecover ::= !(THEN)  // can't get this kind of stuff to work :(
private scriptThenBlockRecover ::= !(IF | RPAREN !RPAREN)  // can't get this kind of stuff to work :(
private scriptAssignmentRecover ::= !(RPAREN | IDENTIFIER)
private scriptBlockRecover ::= !(IF | RPAREN)  // can't get this kind of stuff to work :(
private worldScriptRecover ::= !(RPAREN)
private comma_separated_list_recover ::= !(RPAREN)  // wrong, interferes with other recovers!
