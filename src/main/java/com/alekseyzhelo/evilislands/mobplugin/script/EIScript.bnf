{
  parserClass="com.alekseyzhelo.evilislands.mobplugin.script.EIScriptParser"

  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptPsiElement"
  extends="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptPsiElementImpl"

  psiClassPrefix="EI"
  psiImplClassSuffix="Impl"
  psiPackage="com.alekseyzhelo.evilislands.mobplugin.script.psi"
  psiImplPackage="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl"

  elementTypeHolderClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptTypes"
  elementTypeClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptElementType"
  tokenTypeClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.ScriptTokenType"

  psiImplUtilClass="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptPsiImplUtil"
}

//utility---------------
//                     |
//                    \|/
scriptFile ::= functionDeclaration+ | globalVars? declarations? scripts? worldScript?
// apparently this structure is not enforced by game.exe,
// declarations and implementations can be interspersed through the script text
// such disorder will not stand, of course

// utility
private meta comma_separated_list ::= <<param>> ( &RPAREN | (( COMMA <<param>> )*))
{
  pin(".*")=1
  recoverWhile=comma_separated_list_recover
}

//noinspection BnfUnusedRule
private ignored ::= (WHOLE_LINE_COMMENT COMMENT) // just to generate the ScriptToken

functionDeclaration ::= IDENTIFIER formalParams (COLON type)?
{
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EICallableDeclaration"
  methods=[getActualType getCallableParams getCallableType]
}
// utility end

private formalParams ::= LPAREN <<comma_separated_list (formalParameter)>>? RPAREN

formalParameter ::= IDENTIFIER COLON type
{
  pin=1
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
}

globalVars ::= GLOBALVARS LPAREN globalVarsDefs? RPAREN  {methods=[toString]}

declarations ::= scriptDeclaration+  {methods=[toString]}

scripts ::= scriptImplementation+  {methods=[toString]}

worldScript ::= WORLDSCRIPT LPAREN scriptThenBody RPAREN {pin=2 recoverWhile=worldScriptRecover methods=[toString]}

private globalVarsDefs ::= <<comma_separated_list (globalVar)>>

globalVar ::= IDENTIFIER COLON type
{
  pin=1
  recoverWhile=globalVarRecover
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
  methods=[toString]
}

// TODO: do script params shadow global vars?
scriptDeclaration ::= DECLARESCRIPT IDENTIFIER formalParams
{
  pin=1
  recoverWhile=scriptDeclarationRecover
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EICallableDeclaration"
  methods=[getCallableParams getCallableType toString]
}

scriptImplementation ::= SCRIPT IDENTIFIER LPAREN scriptBody RPAREN
{
  pin=1
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptImplementationMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
  methods=[getReference toString]
} // TODO implements own interface?

private scriptBody ::= scriptBlock+  // or *?

// TODO: flatten this out as well?
scriptBlock ::= scriptIfBlock scriptThenBlock {pin=1 recoverWhile=scriptBlockRecover methods=[toString]}

scriptIfBlock ::= IF LPAREN ifConjunction RPAREN {pin=1 recoverWhile=scriptIfBlockRecover methods=[toString]}

private ifConjunction ::= functionCall*

//  recoverWhile=scriptThenBlockRecover
scriptThenBlock ::= THEN LPAREN scriptThenBody RPAREN  {pin=2 recoverWhile=scriptThenBlockRecover methods=[toString]}

private scriptThenBody ::= scriptStatement*

// TODO: how to do references here?
// TODO: should be called a statement, actually
scriptStatement ::= forBlock
                  | expressionStatement
{
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIStatementBase"
}

// TODO: Sum and ForIf?
// TODO: pin=2?
// TODO: annotation for For arguments!  | more or less done
expressionStatement ::= functionCall | assignment {extends=scriptStatement methods=[getType toString]}
forBlock ::= FOR LPAREN variableAccess COMMA reference_expression RPAREN LPAREN scriptThenBody RPAREN
{
  pin=1
  extends=scriptStatement
  methods=[getType toString]
}

// TODO: how to do references here?
expression ::= reference_expression
             | literal
{
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIExpressionBase"
  consumeTokenMethod="consumeTokenFast"
}

literal ::= FLOATNUMBER | CHARACTER_STRING
{
  extends=expression
  methods=[getType getReference toString]
  consumeTokenMethod="consumeTokenFast"
}
private reference_expression ::= functionCall | variableAccess

// TODO: append !LPAREN ?
variableAccess ::= IDENTIFIER
{
  extends=expression
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
  methods=[getReference getType toString]
  consumeTokenMethod="consumeTokenFast"
}

functionCall ::= IDENTIFIER params
{
  extends=expression
  mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EIScriptNamedElementMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EIScriptNamedElementMixin"
  methods=[getReference getType getNthArgument toString]
  consumeTokenMethod="consumeTokenFast"
}

// TODO: type checking!
params ::=  LPAREN <<comma_separated_list (expression)>>? RPAREN {pin=1 consumeTokenMethod="consumeTokenFast"}

// TODO: handle no error on right part missing
assignment ::= variableAccess EQUALS expression {extends=expression
                                                 pin=1
                                                 recoverWhile=scriptAssignmentRecover
                                                 methods=[getType toString]
                                                 consumeTokenMethod="consumeTokenFast"} // TODO: this pin and error recovery stuff

type ::= FLOAT | STRING | OBJECT | GROUP {mixin="com.alekseyzhelo.evilislands.mobplugin.script.psi.impl.EITypeMixinImpl"
  implements="com.alekseyzhelo.evilislands.mobplugin.script.psi.base.EITypeMixin"}

private globalVarRecover ::= !(IDENTIFIER | COMMA | RPAREN)
private scriptDeclarationRecover ::= !(DECLARESCRIPT | SCRIPT)
private scriptIfBlockRecover ::= !(THEN)  // can't get this kind of stuff to work :(
private scriptThenBlockRecover ::= !(IF | RPAREN !RPAREN)  // can't get this kind of stuff to work :(
private scriptAssignmentRecover ::= !(RPAREN | IDENTIFIER)
private scriptBlockRecover ::= !(IF | RPAREN)  // can't get this kind of stuff to work :(
private worldScriptRecover ::= !(RPAREN)
private comma_separated_list_recover ::= !(RPAREN)  // wrong, interferes with other recovers!
